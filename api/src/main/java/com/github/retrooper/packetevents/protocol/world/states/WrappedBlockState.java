package com.github.retrooper.packetevents.protocol.world.states;

import com.github.retrooper.packetevents.PacketEvents;
import com.github.retrooper.packetevents.manager.server.ServerVersion;
import com.github.retrooper.packetevents.protocol.world.states.type.StateType;
import com.github.retrooper.packetevents.protocol.world.states.type.StateTypes;
import com.github.retrooper.packetevents.protocol.world.states.type.StateValue;
import org.jetbrains.annotations.NotNull;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Objects;

/**
 * This class is designed to take advantage of modern minecraft versions
 * It has also been designed so that legacy versions can use this system
 * <p>
 * Write your code once, and use it everywhere.  Platform and version agnostic.
 * <p>
 * The mappings for legacy versions (1.12) was generated by setting blocks in the world at the pos id * 2, 255, data * 2
 * and then the world was upgraded to 1.18 and the block was read, dumping it all into a text file.
 * <p>
 * Mappings from modern versions are from ViaVersion, who have a similar (but a bit slower) system.
 */
public class WrappedBlockState {
    StateType type;
    HashMap<StateValue, Object> data = new HashMap<>();

    private static final WrappedBlockState AIR = new WrappedBlockState(StateTypes.AIR, null);

    private static final HashMap<String, WrappedBlockState> BY_STRING = new HashMap<>();
    private static final HashMap<Integer, WrappedBlockState> BY_ID = new HashMap<>();
    private static final HashMap<WrappedBlockState, String> INTO_STRING = new HashMap<>();
    private static final HashMap<WrappedBlockState, Integer> INTO_ID = new HashMap<>();

    public WrappedBlockState(StateType type, String[] data) {
        this.type = type;
        if (data == null) return;
        for (String s : data) {
            String[] split = s.split("=");
            StateValue value = StateValue.valueOf(split[0]);
            this.data.put(value, value.getParser().apply(split[1]));
        }
    }

    // Begin all block data types
    //public Object getAge(StateValue toGet) {
    //    return (toGet.getReturnType()) data.get(toGet);
    //}

    // End all block data types

    public int getGlobalId() {
        return INTO_ID.get(this);
    }

    @Override
    public String toString() {
        return INTO_STRING.get(this);
    }

    @NotNull
    public WrappedBlockState getByGlobalId(int globalID) {
        return BY_ID.getOrDefault(globalID, AIR);
    }

    @NotNull
    public WrappedBlockState getByString(String string) {
        return BY_STRING.getOrDefault(string, AIR);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        WrappedBlockState that = (WrappedBlockState) o;
        return this.type == that.type && this.data == that.data;
    }

    @Override
    public int hashCode() {
        return Objects.hash(type, data);
    }

    // TODO: 1.16.0/1.16.1 and 1.13.0/1.13.1 support
    private static String getMappingServerVersion(ServerVersion serverVersion) {
        if (serverVersion.isOlderThan(ServerVersion.V_1_13)) {
            return "legacy_block_mappings.txt";
        } else if (serverVersion.isOlderThan(ServerVersion.V_1_14)) {
            return "13.txt";
        } else if (serverVersion.isOlderThan(ServerVersion.V_1_15)) {
            return "14.txt";
        } else if (serverVersion.isOlderThan(ServerVersion.V_1_16)) {
            return "15.txt";
        } else if (serverVersion.isOlderThan(ServerVersion.V_1_16_2)) {
            return "16.txt";
        } else {
            return "17.txt";
        }
    }

    static {
        String mappingName = getMappingServerVersion(PacketEvents.getAPI().getServerManager().getVersion());
        InputStream mappings = WrappedBlockState.class.getClassLoader().getResourceAsStream("assets/mappings/block/" + mappingName);
        BufferedReader paletteReader = new BufferedReader(new InputStreamReader(mappings));

        if (PacketEvents.getAPI().getServerManager().getVersion().isOlderThan(ServerVersion.V_1_13)) {
            loadLegacy(paletteReader);
        } else {
            loadModern(paletteReader);
        }
    }

    private static void loadLegacy(BufferedReader reader) {
        String line;
        try {
            while ((line = reader.readLine()) != null) {
                String[] split = line.split(",");
                int id = Integer.parseInt(split[0]);
                int data = Integer.parseInt(split[1]);
                int combinedID = id + (data << 12);

                int endIndex = split[2].indexOf("[");

                String blockString = split[2].substring(0, endIndex != -1 ? endIndex : split[2].length());

                StateType type = StateTypes.getByName(blockString);
                type.updateInternalBlockRepresentationsOptimization(id);

                String[] dataStrings = null;
                if (endIndex != -1) {
                    dataStrings = split[2].substring(endIndex + 1, line.length() - 1).split(",");
                }

                WrappedBlockState state = new WrappedBlockState(type, dataStrings);

                BY_STRING.put(split[2], state);
                BY_ID.put(combinedID, state);
                INTO_STRING.put(state, split[2]);
                INTO_ID.put(state, combinedID);
            }
        } catch (IOException e) {
            PacketEvents.getAPI().getLogManager().debug("Palette reading failed! Unsupported version?");
            e.printStackTrace();
        }
    }

    private static void loadModern(BufferedReader reader) {
        String line;
        try {
            while ((line = reader.readLine()) != null) {
                int index = line.indexOf("[");
                int afterID = line.indexOf(" ");
                int id = Integer.parseInt(line.substring(0, line.indexOf(" ")));

                String blockString = line.substring(afterID + 1, index == -1 ? line.length() : index);
                StateType type = StateTypes.getByName(blockString);
                type.updateInternalBlockRepresentationsOptimization(id);

                String[] data = null;
                if (index != -1) {
                    data = line.substring(index + 1, line.length() - 1).split(",");
                }

                WrappedBlockState state = new WrappedBlockState(type, data);

                BY_STRING.put(blockString, state);
                BY_ID.put(id, state);
                INTO_STRING.put(state, blockString);
                INTO_ID.put(state, id);
            }
        } catch (IOException e) {
            PacketEvents.getAPI().getLogManager().debug("Palette reading failed! Unsupported version?");
            e.printStackTrace();
        }
    }
}
